import { EzComponent } from "./EzComponent";
/**
 * @description Type of timer cancel events
 */
export declare type TimerCancelFunction = () => void;
/**
 * @description Returned by input and change events.  Has a value property.
 * @export
 * @interface ValueEvent
 * @extends {Event}
 * @group Event Types
 * @example @Change("myInput")
 * myInputChange(e: ValueEvent) {
 *  console.log("Input changed to " + e.value);
 * }
 */
export interface ValueEvent extends Event {
    value: string;
}
/** @ignore */
export interface ExtendedEventMap extends HTMLElementEventMap {
    input: ValueEvent;
    change: ValueEvent;
}
/** @ignore */
declare global {
    interface HTMLElement {
        addEventListener<K extends keyof ExtendedEventMap>(type: K, listener: (this: HTMLElement, ev: ExtendedEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    }
}
/**
 * @description Decorator to bind a generic event to an element
 * @param htmlElementID the element to bind the event to
 * @param type the event to bind
 * @returns DecoratorCallback
 * @export
 * @group Event Decorators
 * @example
 * @GenericEvent("myButton", "click")
 * myButtonClick(e: MouseEvent) {
 *    console.log("Button was clicked");
 * }
 */
export declare function GenericEvent<K extends keyof HTMLElementEventMap>(htmlElementID: string, type: K): <This extends EzComponent>(target: (this: This, event: ExtendedEventMap[K]) => void, context: ClassMethodDecoratorContext<This, (this: This, event: ExtendedEventMap[K]) => void>) => void;
/**
 * @description Decorator to bind a window event to the window
 * @param type the event to bind
 * @returns DecoratorCallback
 * @export
 * @group Event Decorators
 * @example
 * @WindowEvent("resize")
 * onResize(e: WindowEvent) {
 *   console.log("Window was resized");
 * }
 */
export declare function WindowEvent<K extends keyof WindowEventMap>(type: K): <This extends EzComponent>(target: (this: This, event: WindowEventMap[K]) => void, context: ClassMethodDecoratorContext<This, (this: This, event: WindowEventMap[K]) => void>) => void;
/**
 * @description Decorator to bind a click event to an element
 * @param htmlElementID the element to bind the event to
 * @returns DecoratorCallback
 * @export
 * @group Event Decorators
 * @example
 * @Click("myButton")
 * myButtonClick(e: MouseEvent) {
 *   console.log("Button was clicked");
 * }
 */
export declare function Click<This extends EzComponent>(htmlElementID: string): <This_1 extends EzComponent>(target: (this: This_1, event: MouseEvent) => void, context: ClassMethodDecoratorContext<This_1, (this: This_1, event: MouseEvent) => void>) => void;
/**
 * @description Decorator to bind a blur event to an element
 * @param htmlElementID the element to bind the event to
 * @returns DecoratorCallback
 * @export
 * @group Event Decorators
 * @example
 * @Blur("myInput")
 * myInputBlur(e: FocusEvent) {
 *  console.log("Input lost focus");
 * }
 */
export declare function Blur<This extends EzComponent>(htmlElementID: string): <This_1 extends EzComponent>(target: (this: This_1, event: FocusEvent) => void, context: ClassMethodDecoratorContext<This_1, (this: This_1, event: FocusEvent) => void>) => void;
/**
 * @description Decorator to bind a change event to an element.  For checkboxes, this will return "on" when checked or "" when unchecked.
 * @param htmlElementID the element to bind the event to
 * @returns DecoratorCallback
 * @export
 * @group Event Decorators
 * @example
 * @Change("myInput")
 * myInputChange(e: ChangeEvent) {
 *   console.log("Input changed");
 */
export declare function Change<This extends EzComponent>(htmlElementID: string): <This_1 extends EzComponent>(target: (this: This_1, event: ValueEvent) => void, context: ClassMethodDecoratorContext<This_1, (this: This_1, event: ValueEvent) => void>) => void;
/**
 * @description Decorator to bind an input event to an element
 * @param htmlElementID the element to bind the event to
 * @returns DecoratorCallback
 * @export
 * @group Event Decorators
 * @example
 * @Input("myInput")
 * myInputChange(e: InputEvent) {
 *  console.log("Input changed");
 * }
 */
export declare function Input<This extends EzComponent>(htmlElementID: string): <This_1 extends EzComponent>(target: (this: This_1, event: ValueEvent) => void, context: ClassMethodDecoratorContext<This_1, (this: This_1, event: ValueEvent) => void>) => void;
/**
 * @description Decorator to call a method periodically with a timer
 * @param intervalMS the interval in milliseconds to call the method
 * @returns DecoratorCallback
 * @note This executes repeatedly.  The decorated function is passed a cancel function that can be called to stop the timer.
 * @export
 * @group Event Decorators
 * @example
 * let counter=0;
 * @Timer(1000)
 * myTimerMethod(cancel: TimerCancelMethod) {
 *   console.log("Timer method called once per second");
 *   if (counter++ > 5) cancel();
 */
export declare function Timer<This extends EzComponent>(intervalMS: number): <This_1 extends EzComponent, Value extends () => void>(target: (this: This_1, cancelFn: TimerCancelFunction) => void, context: ClassMethodDecoratorContext<This_1, (this: This_1, cancel: Value) => void>) => void;
